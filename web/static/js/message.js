import React from "react"
import ReactDOM from "react-dom"
import {Socket} from "phoenix"
import {Starter} from "./starter"

let Remarkable = require('remarkable')
let $ = require("jquery")
let _ = require("lodash")

let socket;
let channel;

var Bootstrap = React.createClass({
  getInitialState: function() {
    return {login: false, token: "", name: "", chat: "", user: ""};
  },
  handleLogin: function(data) {
    this.setState({login: true, token: data.token, name: data.name, chat: data.chat, user: data.user});
  },
  closeChat: function(){
    this.setState({login: false})
  },
  render: function() {
    return (
      <section>
      {(() => {
        if (this.state.login) {
          return <CommentBox 
                  closeChat={this.closeChat}
                  token={this.state.token} 
                  name={this.state.name} 
                  chat={this.state.chat} 
                  user={this.state.user}
                  />;
        } else {
          return <SimpleLogin login={this.state.login} handleLogin={this.handleLogin}/>;
        }
      })()}
      </section>
    );
  }
});

var Comment = React.createClass({
  rawMarkup: function() {
    var md = new Remarkable();
    var rawMarkup = md.render(this.props.children.toString());
    return { __html: rawMarkup };
  },
  topOwnerClass: function() {
    var topClass = ' ui '; 
    if (!this.props.mine) {
      topClass += ' right aligned blue ';
    }
    topClass += ' top attached block header';
    return topClass;
  },
  bottomOwnerClass: function() {
    var bottomClass = 'ui ';
    if (!this.props.mine) {
      bottomClass += ' right aligned ';
    }
    bottomClass += ' bottom attached segment';
    return bottomClass;
  },
  render: function() {
    return (
      <div className="comment column">
        <h4 className={this.topOwnerClass()}>{this.props.author}</h4>
        <div className={this.bottomOwnerClass()} dangerouslySetInnerHTML={this.rawMarkup()} />
      </div>
    );
  }
});

var CommentBox = React.createClass({
  preloadCommentsFromServer: function() {    
    var chat = this.props.chat;
    var token = this.props.token;
    $.ajax("/api/user/messages/preload", {
      method: "GET",
      data: {token: token, chat: chat}, 
      success: resp => {
        if(!_.isEmpty(resp)) {
          var comments = this.state.data
          var newComments = comments
          _.forEach(resp, (item) => {
            var comment = {};
            if(_.findIndex(newComments, ['id', item.id]) < 0) {
              if (!_.isEmpty(item.user)) { 
                comment = {id: item.id, text: item.text, author: item.user.name, mine: true}
              } else {
                comment = {id: item.id, text: item.text, author: item.operator.name, mine: false}
              }            
              newComments = newComments.concat([comment])
            }
          })
          if(!_.isEmpty(newComments)) {
            this.setState({data: newComments});
          }
        }
      }
    })
  },  
  loadCommentsFromServer: function() {    
    channel.on("new_msg", payload => {
      var comments = this.state.data
      if(_.findIndex(comments, ['id', payload.id]) < 0) {
        var mine = false;
        if(payload.role === 'user') {
          mine = true;
        }
        var comment = {id: payload.id, text: payload.body, author: payload.author, mine: mine}
        var newComments = comments.concat([comment])
        this.setState({data: newComments});
      }
    })    
  },
  handleCommentSubmit: function(comment) {
    var comments = this.state.data
    // Optimistically set an id on the new comment. It will be replaced by an
    // id generated by the server. In a production application you would likely
    // not use Date.now() for this and would have a more robust system in place.
    comment.id = Date.now()
    var newComments = comments.concat([comment])
//    this.setState({data: newComments});
    channel.push("new_msg", {body: comment.text, author: comment.author, token: comment.token, guest: this.props.user, role: "user"})    
  },
  channelClose: function(msg) {
    channel.push("usr_leave", {role: "user"})
      .receive("ok", resp => { console.log("Left successfully " + msg, resp) })
      .receive("error", resp => { console.log("Unable to leave "+ msg, resp) })

  },
  componentWillUnmount: function() {
    this.channelClose("user is closing the window")
  },
  getInitialState: function() {
    return {data: [], user: this.props.user};
  },
  componentWillMount: function() {
    socket = new Socket("/socket", {params: {token: this.props.token}})
    socket.connect()
    // Now that you are connected, you can join channels with a topic:
    channel = socket.channel("room:" + this.props.chat, {role: "user", guest: this.props.name})
    channel.join()
      .receive("ok", resp => { console.log("Joined successfully", resp) })
      .receive("error", resp => { console.log("Unable to join", resp) })

    this.loadCommentsFromServer();
  },
  componentDidMount: function() {
    this.preloadCommentsFromServer();
  },
  render: function() {
    return (
      <div className="commentBox">
        <h4 className="ui top attached block header">
          <div className="ui animated fade button" tabIndex="0" onClick={this.props.closeChat}>
            <div className="visible content">Comments</div>
            <div className="hidden content">Close this chat</div>
          </div>
        </h4>        
        <CommentList data={this.state.data} />
        <CommentForm token={this.props.token} name={this.props.name} onCommentSubmit={this.handleCommentSubmit} />
      </div>
    );
  }
});

var CommentList = React.createClass({
  render: function() {
    var commentNodes = this.props.data.map(function(comment) {
      return (        
        <Comment author={comment.author} key={comment.id} mine={comment.mine}>
          {comment.text}
        </Comment>
      );
    });
    return (
      <div className="commentList ui list">
        {commentNodes}
      </div>
    );
  }
});

var CommentForm = React.createClass({
  getInitialState: function() {
    return {author: '', text: '', token: ''};
  },
  componentDidMount: function() {
    this.setState({author: this.props.name, text: '', token: this.props.token});
  },
  handleTextChange: function(e) {
    this.setState({text: e.target.value});
  },
  handleSubmit: function(e) {
    e.preventDefault();
    var author = this.state.author.trim();
    var text = this.state.text.trim();
    var token = this.state.token.trim();
    if (!text || !author || !token) {
      return;
    }
    this.props.onCommentSubmit({author: author, text: text, token: token});
    this.setState({author: author, text: '', token: token});
  },
  render: function() {
    return (
      <form className="commentForm" onSubmit={this.handleSubmit}>
        <div className="ui action input large">
        <input
          type="hidden"
          value={this.state.token}
        />
        <input
          type="hidden"
          value={this.state.author}
        />
        <input
          type="text"
          placeholder="Say something..."
          value={this.state.text}
          onChange={this.handleTextChange}
        />
        <input type="submit" value="Post" className="ui teal button large"/>
        </div>
      </form>
    );
  }
});

var SimpleLogin = React.createClass({
  getInitialState: function() {
    return {email: ''};
  },
  handleSubmit: function(e) {
    e.preventDefault();
    let props = this.props;
    //chiamare in remoto per loggare utente
    $.ajax("/api/create/" + this.state.email, {
      method: "GET",
      success: function(data) {
        console.log(data);
        if (!props.login) {
          props.handleLogin(data);
        }
      }
    });    
  },
  handleEmailChange: function(e) {
    this.setState({email: e.target.value});
  },
  render: function() {
    return (
      <form className="loginForm" onSubmit={this.handleSubmit}>
          <div className="ui action input large">
            <input            
              type="text"
              placeholder="Your Email"
              value={this.state.email}
              onChange={this.handleEmailChange}
            />
            <input type="submit" value="Start" className="ui teal button large primary"/>
          </div>
      </form>
    );
  }
});

/*
creare nuovo componente alternativo che si mostra quando utente nn loggato
passare il suo sato=token + email come props dell altro comp
inizializzare comp dei commenti con il socket + token
*/
Starter(<Bootstrap/>,'content')
